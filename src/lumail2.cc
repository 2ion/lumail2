/**
 *
 * The main entry-point for lumail2.
 *
 */

extern "C"
{
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
}

#include <iostream>
#include <gmime/gmime.h>
#include <getopt.h>

#include "maildir.h"
#include "message.h"
#include "message_part.h"
#include "screen.h"
#include "config.h"


/**
 * External functions implemented in *_lua.cc
 */
extern void InitConfig (lua_State * l);
extern void InitMaildir (lua_State * l);
extern void InitMessage (lua_State * l);
extern void InitMessagePart (lua_State * l);
extern void InitScreen (lua_State * l);



/**
 * The entry point to our code.
 */
int main (int argc, char *argv[])
{
    /**
     * Initiate mime.
     */
    g_mime_init (0);

    /**
     * Setup Lua - TODO move to singleton.
     */
    lua_State *l = luaL_newstate ();
    luaL_openlibs (l);


    /**
     * Load our bindings.
     */
    InitConfig (l);
    InitMaildir (l);
    InitMessage (l);
    InitMessagePart (l);
    InitScreen (l);


    /**
     * Parse command-line arguments
     */
    int c;


    /**
     * Flags/things set by the command-line arguments.
     */
    std::vector < std::string > load;
    bool curses = true;


    while (1)
    {
	static struct option long_options[] = {
	    {"no-curses", no_argument, 0, 'n'},
	    {"load-file", required_argument, 0, 'l'},
	    {0, 0, 0, 0}
	};

	/* getopt_long stores the option index here. */
	int option_index = 0;

	c = getopt_long (argc, argv, "l:n", long_options, &option_index);

	/* Detect the end of the options. */
	if (c == -1)
	    break;

	switch (c)
	{
	case 'l':
	    load.push_back (optarg);
	    break;
	case 'n':
	    curses = false;
	    break;
	}
    }


    /**
     * If we're supposed to use curses then do so.
     */
    if (curses == true)
    {
        CScreen *screen = CScreen::instance ();
	screen->setup ();
    }


    /**
     * Error-message, if any, generated by lua.
     */
    const char *err = NULL;

    /**
     * Load the named script file(s).
     */
    if (!load.empty ())
    {
      for (std::string filename:load)
	{
	    int erred = luaL_dofile (l, filename.c_str ());
	    if (erred)
		err = luaL_checkstring (l, -1);
	}
    }
    else
    {
	// TODO :Run main loop
    }


    /**
     * If we're using Curses then tear it down.
     */
    if (curses == true)
      {
        CScreen *screen = CScreen::instance ();
	screen->teardown ();
      }


    /**
     * Close Lua, GMime.
     */
    lua_close (l);
    g_mime_shutdown ();

    /**
     * If we received an error show that.
     */
    if (err != NULL)
    {
	std::cerr << "Error from lua" << std::endl;
        std::cerr << err << std::endl;
    }

    return 0;
}
